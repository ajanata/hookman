;    HookMan - System Hook Manager for TI-83+ Series.
;    Copyright (C) 2007  Andy Janata
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License along
;    with this program; if not, write to the Free Software Foundation, Inc.,
;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
;
;	 You can contact the author via electronic mail at <ajanata@gmail.com>,
;	 or by writing to Andy Janata, 178 E. 5th St., Brewster, OH 44613 USA.


;	This file contains HookMan's implementaion of every hook. These are just
;	stubs which stick a number into b (after pushing bc to the stack) and jump
;	to a unified hook handler.
;	Also contains utility routines to (un)install hooks.

;	Every hook must start with a $83 byte. This is used to verify the address
;	of the hook is valid. It is not executed. ($83 is "add a,e", in case you
;	were wondering.)


; Each hook is 1+1+2+3=7 bytes

;9B78 - Link Activity Hook
hookCode:
hookLinkActivity:
	.db $83
	push bc
	ld b,LinkActivityHook
	jp doHook

;9B7C - Cursor Hook
hookCursor:
	.db $83
	push bc
	ld b,CursorHook
	jp doHook
	
;9B84 - Raw Key Hook
hookRawKey:
	.db $83
	push bc
	ld b,RawKeyHook
	jp doHook
	
;9B88 - GetCSC Hook
hookGetCSC:
	.db $83
	push bc
	ld b,GetCSCHook
	jp doHook
	
;9B8C - Homescreen Hook
hookHomescreen:
	.db $83
	push bc
	ld b,HomescreenHook
	jp doHook
	
;9B90 - Window Hook
hookWindow:
	.db $83
	push bc
	ld b,WindowHook
	jp doHook
	
;9B94 - Graph Hook
hookGraph:
	.db $83
	push bc
	ld b,GraphHook
	jp doHook
	
;9B98 - Y= Hook
hookYEqu:
	.db $83
	push bc
	ld b,YEquHook
	jp doHook
	
;9B9C - Font Hook
hookFont:
	.db $83
	push bc
	ld b,FontHook
	jp doHook
	
;9BA0 - Regraph Hook
hookRegraph:
	.db $83
	push bc
	ld b,RegraphHook
	jp doHook
	
;9BA4 - Graphics Hook
hookGraphics:
	.db $83
	push bc
	ld b,GraphicsHook
	jp doHook
	
;9BA8 - Trace Hook
hookTrace:
	.db $83
	push bc
	ld b,TraceHook
	jp doHook
	
;9BAC - Parser Hook
hookParser:
	.db $83
	push bc
	ld b,ParserHook
	jp doHook
	
;9BB0 - App Change Hook
hookAppChange:
	.db $83
	push bc
	ld b,AppChangeHook
	jp doHook
	
;9BB4 - Catalog 1 Hook
hookCatalog1:
	.db $83
	push bc
	ld b,Catalog1Hook
	jp doHook
	
;9BB8 - Help Hook
hookHelp:
	.db $83
	push bc
	ld b,HelpHook
	jp doHook
	
;9BBC - cxRedisp Hook
hookcxRedisp:
	.db $83
	push bc
	ld b,cxRedispHook
	jp doHook
	
;9BC0 - Menu Hook
hookMenu:
	.db $83
	push bc
	ld b,MenuHook
	jp doHook
	
;9BC4 - Catalog 2 Hook
hookCatalog2:
	.db $83
	push bc
	ld b,Catalog2Hook
	jp doHook
	
;9BC8 - Token Hook
hookToken:
	.db $83
	push bc
	ld b,TokenHook
	jp doHook
	
;9BCC - Localize Hook
hookLocalize:
	.db $83
	push bc
	ld b,LocalizeHook
	jp doHook
	
;9BD0 - Silent Link Hook
hookSilentLink:
	.db $83
	push bc
	ld b,SilentLinkHook
	jp doHook
	
;9BD4 - USB Activity Hook
hookUSBActivity:
	.db $83
	push bc
	ld b,USBActivityHook
	jp doHook
	


;	Actually process the hook.
;	IN: b: Hook identification number (see defines in hooklist.inc).
;	   top of stack: Old bc to pass to the real hook.
doHook:
	; this dummy hook will not work for all of the different hooks!
	pop bc
	ret
	
	
;	Install the given hook number. Assumes that any current hook has
;	been saved if needed and also that there are hooks in the chain
;	that belong to this hook.
;	IN: a: Hook number to install.
;	OUT: hook is installed and enabled
;	DESTROYS: everything
installHook:
	di				; so the old hook can't be run, if it's already active
	ld hl,HookInfoLUT
	ld de,hookCode
	or a			; we need to skip our loop entirely for hook 0
	jp z,++_
	ld b,a
_:
	inc hl			; the LUT has 2-byte entries
	inc hl
	inc de			; each hook's code is 7 bytes
	inc de			; 2
	inc de
	inc de			; 4
	inc de
	inc de			; 6
	inc de
	djnz -_
__:
	; now hl points to the entry in the LUT and de points to the code for that hook
	bcall(_LdHLInd)
	; now hl points to the actual information block for the hook
	inc hl
	push hl
	bcall(_LdHLInd)		; yay pointer to a pointer!
	; and now, finally, hl points to the hook block in RAM
	; de still points to the address of our hook handler
	ld (hl),e
	inc hl
	ld (hl),d
	in a,(6)		; our page
	inc hl
	ld (hl),a		; now the hook ram block is set up right
	pop hl			; hl points to the ram block address in the hook info block now
	inc hl			; move past ram block address
	inc hl
	ld b,0
	ld c,(hl)		; bc now has the flags offset
	ex de,hl		; de points to flag offset byte in hook info block, hl is junk
	ld hl,flags
	add hl,bc		; hl points to the flag byte
	inc de			; de points to bitmask for hook enable flag
	ld a,(de)		; load the bitmask into a
	or (hl)			; set the bit for this hook
	ld (hl),a		; store it back to the flag byte
	; ... and I think we're done
	ei
	ret












